generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums per DB Spec
enum price_time_band {
  day
  night
}

enum price_visit_type {
  incall
  outcall
}

enum price_unit {
  ONE_H @map("1h")
  TWO_H @map("2h")
  night
  other
}

enum price_outcall_travel {
  none
  client_taxi
  included
}

enum processing_state {
  pending
  processing
  processed
  failed
}

// Minimal auth subset to verify connectivity and migrations
model User {
  id             BigInt   @id @default(autoincrement())
  email          String?  @unique @db.Text
  emailVerified  Boolean  @default(false) @map("email_verified")
  status         String   @default("active") @db.Text
  lastLoginAt    DateTime? @map("last_login_at")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @default(now()) @map("updated_at")
  sessions       Session[]
  challenges     AuthChallenge[]
  profiles       Profile[]

  @@index([lastLoginAt])
  @@index([status])
  @@map("users")
}

model Session {
  id         BigInt   @id @default(autoincrement())
  userId     BigInt    @map("user_id")
  tokenHash  String   @map("token_hash") @db.Text
  issuedAt   DateTime @default(now()) @map("issued_at")
  expiresAt  DateTime @map("expires_at")
  revokedAt  DateTime? @map("revoked_at")
  ip         String?  @db.Text
  userAgent  String?  @map("user_agent") @db.Text

  user User @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@index([userId, expiresAt])
  @@map("sessions")
}

/// auth.auth_challenges
model AuthChallenge {
  id            BigInt    @id @default(autoincrement())
  userId        BigInt?   @map("user_id")
  channel       String    @db.Text
  purpose       String    @db.Text
  target        String    @db.Text
  tokenHash     String?   @unique @map("token_hash") @db.Text
  deepLinkHash  String?   @unique @map("deep_link_hash") @db.Text
  state         String    @default("pending") @db.Text
  meta          Json?
  expiresAt     DateTime  @map("expires_at")
  verifiedAt    DateTime? @map("verified_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([target, channel, purpose, state])
  @@index([expiresAt])
  @@map("auth_challenges")
}

model Profile {
  id           BigInt   @id @default(autoincrement())
  userId       BigInt   @map("user_id")
  status       String   @default("draft") @db.Text
  nickname     String   @db.Text
  isVisible    Boolean  @default(false) @map("is_visible")
  publishedAt  DateTime? @map("published_at")
  expiresAt    DateTime? @map("expires_at")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @default(now()) @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Restrict)

  photos ProfilePhoto[]
  services ProfileService[]
  customServices ProfileCustomService[]
  prices ProfilePrice[]

  @@index([userId, status])
  @@map("profiles")
}

model ProfilePhoto {
  id          BigInt  @id @default(autoincrement())
  profileId   BigInt  @map("profile_id")
  storageKey  String  @unique @map("storage_key") @db.Text
  sha256Hex   String  @map("sha256_hex") @db.Text
  isCover     Boolean @default(false) @map("is_cover")
  position    Int     @default(100)
  sizeBytes   Int     @map("size_bytes")
  mime        String  @db.Text
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @default(now()) @map("updated_at")

  // ADR-004 processing fields
  virusScanned     Boolean   @default(false) @map("virus_scanned")
  exifStripped     Boolean   @default(false) @map("exif_stripped")
  watermarkApplied Boolean   @default(false) @map("watermark_applied")
  processingState  String    @default("pending") @map("processing_state") @db.Text
  processingError  String?   @map("processing_error") @db.Text
  nsfwScore        Decimal?  @map("nsfw_score") @db.Decimal(4, 3)
  processedAt      DateTime? @map("processed_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, sha256Hex])
  @@unique([profileId, position])
  @@index([profileId])
  @@index([processingState])
  @@map("profile_photos")
}

// Services catalog
model Service {
  id           BigInt   @id @default(autoincrement())
  groupCode    String   @map("group_code") @db.Text
  code         String   @unique @db.Text
  name         String   @db.Text
  description  String?  @db.Text
  requiresNote Boolean  @default(false) @map("requires_note")
  isActive     Boolean  @default(true) @map("is_active")
  position     Int      @default(100)
  i18n         Json?
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @default(now()) @map("updated_at")
  profileServices ProfileService[]

  @@unique([groupCode, code])
  @@index([isActive, groupCode, position])
  @@map("services")
}

// Selected services per profile (m2m)
model ProfileService {
  id        BigInt   @id @default(autoincrement())
  profileId BigInt   @map("profile_id")
  serviceId BigInt   @map("service_id")
  note      String?  @db.Text
  createdAt DateTime @default(now()) @map("created_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  service Service @relation(fields: [serviceId], references: [id], onDelete: Restrict)

  @@unique([profileId, serviceId])
  @@index([profileId])
  @@index([serviceId])
  @@map("profile_services")
}

// Custom free-text services
model ProfileCustomService {
  id        BigInt   @id @default(autoincrement())
  profileId BigInt   @map("profile_id")
  text      String   @db.Text
  createdAt DateTime @default(now()) @map("created_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([profileId])
  @@map("profile_custom_services")
}

// Prices matrix per profile
model ProfilePrice {
  id           BigInt               @id @default(autoincrement())
  profileId    BigInt               @map("profile_id")
  timeBand     price_time_band      @map("time_band")
  visitType    price_visit_type     @map("visit_type")
  unit         price_unit           @map("unit")
  amountMinor  BigInt               @map("amount_minor")
  currency     String               @db.Text
  outcallTravel price_outcall_travel @map("outcall_travel")
  note         String?              @db.Text
  updatedAt    DateTime             @default(now()) @map("updated_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, timeBand, visitType, unit])
  @@index([profileId])
  @@index([visitType, timeBand])
  @@map("profile_prices")
}


